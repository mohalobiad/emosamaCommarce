<?php
/**
 * XLSX export utilities for the AlSaadrose WooCommerce Arabic plugin.
 */

if ( ! defined( 'ABSPATH' ) ) {
    exit;
}

if ( ! class_exists( 'TPPLT_XLSX_Exporter' ) ) {
    /**
     * Convert CSV files generated by WooCommerce into basic XLSX spreadsheets.
     */
    class TPPLT_XLSX_Exporter {
        /**
         * Convert a CSV file to XLSX.
         *
         * @param string $csv_path  Path to the source CSV file.
         * @param string $xlsx_path Destination XLSX path.
         *
         * @throws Exception If the conversion fails.
         */
        public static function convert_csv_to_xlsx( $csv_path, $xlsx_path ) {
            if ( ! file_exists( $csv_path ) ) {
                throw new Exception( __( 'The CSV export file could not be found for XLSX conversion.', 'tpplt' ) );
            }

            if ( ! class_exists( 'ZipArchive' ) ) {
                throw new Exception( __( 'The PHP ZipArchive extension is required to build XLSX exports.', 'tpplt' ) );
            }

            $rows = self::read_csv_rows( $csv_path );

            $zip = new ZipArchive();

            if ( true !== $zip->open( $xlsx_path, ZipArchive::CREATE | ZipArchive::OVERWRITE ) ) {
                throw new Exception( __( 'Unable to create the XLSX export file.', 'tpplt' ) );
            }

            $zip->addFromString( '[Content_Types].xml', self::content_types_xml() );
            $zip->addFromString( '_rels/.rels', self::package_relationships_xml() );
            $zip->addFromString( 'xl/workbook.xml', self::workbook_xml() );
            $zip->addFromString( 'xl/_rels/workbook.xml.rels', self::workbook_relationships_xml() );
            $zip->addFromString( 'xl/worksheets/sheet1.xml', self::worksheet_xml( $rows ) );

            $zip->close();
        }

        /**
         * Read CSV rows using PHP's built-in parser.
         *
         * @param string $csv_path CSV path.
         *
         * @return array
         */
        protected static function read_csv_rows( $csv_path ) {
            $rows = array();

            $handle = fopen( $csv_path, 'r' );

            if ( false === $handle ) {
                throw new Exception( __( 'Unable to read the CSV export before XLSX conversion.', 'tpplt' ) );
            }

            while ( ( $data = fgetcsv( $handle ) ) !== false ) {
                $rows[] = $data;
            }

            fclose( $handle );

            return $rows;
        }

        /**
         * Build the XML for the XLSX content types manifest.
         *
         * @return string
         */
        protected static function content_types_xml() {
            return '<?xml version="1.0" encoding="UTF-8"?>'
                . '<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">'
                . '<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>'
                . '<Default Extension="xml" ContentType="application/xml"/>'
                . '<Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/>'
                . '<Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/>'
                . '</Types>';
        }

        /**
         * Build package-level relationships.
         *
         * @return string
         */
        protected static function package_relationships_xml() {
            return '<?xml version="1.0" encoding="UTF-8"?>'
                . '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">'
                . '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/>'
                . '</Relationships>';
        }

        /**
         * Build the workbook manifest.
         *
         * @return string
         */
        protected static function workbook_xml() {
            return '<?xml version="1.0" encoding="UTF-8"?>'
                . '<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">'
                . '<sheets>'
                . '<sheet name="Products" sheetId="1" r:id="rId1"/>'
                . '</sheets>'
                . '</workbook>';
        }

        /**
         * Build workbook relationships.
         *
         * @return string
         */
        protected static function workbook_relationships_xml() {
            return '<?xml version="1.0" encoding="UTF-8"?>'
                . '<Relationships xmlns="http://schemas.openxmlformats.org/officeDocument/2006/relationships">'
                . '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/>'
                . '</Relationships>';
        }

        /**
         * Build the worksheet XML with inline string cells.
         *
         * @param array $rows Sheet rows.
         *
         * @return string
         */
        protected static function worksheet_xml( array $rows ) {
            $xml = '<?xml version="1.0" encoding="UTF-8"?>'
                . '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main">'
                . '<sheetData>';

            foreach ( $rows as $index => $row ) {
                $row_number = $index + 1;
                $xml       .= '<row r="' . $row_number . '">';

                foreach ( $row as $column_index => $value ) {
                    $cell_ref = self::column_letter_from_index( $column_index ) . $row_number;
                    $xml     .= '<c r="' . $cell_ref . '" t="inlineStr"><is><t>' . self::xml_escape( $value ) . '</t></is></c>';
                }

                $xml .= '</row>';
            }

            $xml .= '</sheetData></worksheet>';

            return $xml;
        }

        /**
         * Turn a zero-based column index into an Excel column letter.
         *
         * @param int $index Column index starting from zero.
         *
         * @return string
         */
        protected static function column_letter_from_index( $index ) {
            $index  = (int) $index;
            $letter = '';

            while ( $index >= 0 ) {
                $letter = chr( ( $index % 26 ) + 65 ) . $letter;
                $index  = (int) floor( $index / 26 ) - 1;
            }

            return $letter;
        }

        /**
         * Escape XML entities for worksheet values.
         *
         * @param string $value Raw value.
         *
         * @return string
         */
        protected static function xml_escape( $value ) {
            return htmlspecialchars( (string) $value, ENT_QUOTES | ENT_SUBSTITUTE | ENT_XML1 );
        }
    }
}
